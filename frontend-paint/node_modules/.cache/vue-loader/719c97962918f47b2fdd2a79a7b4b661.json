{"remainingRequest":"H:\\Vue js\\Web-based-Paint\\front-end-paint\\node_modules\\vue-loader\\lib\\index.js??vue-loader-options!H:\\Vue js\\Web-based-Paint\\front-end-paint\\src\\App.vue?vue&type=style&index=0&lang=css&","dependencies":[{"path":"H:\\Vue js\\Web-based-Paint\\front-end-paint\\src\\App.vue","mtime":1606488245290},{"path":"H:\\Vue js\\Web-based-Paint\\front-end-paint\\node_modules\\css-loader\\dist\\cjs.js","mtime":499162500000},{"path":"H:\\Vue js\\Web-based-Paint\\front-end-paint\\node_modules\\vue-loader\\lib\\loaders\\stylePostLoader.js","mtime":499162500000},{"path":"H:\\Vue js\\Web-based-Paint\\front-end-paint\\node_modules\\postcss-loader\\src\\index.js","mtime":499162500000},{"path":"H:\\Vue js\\Web-based-Paint\\front-end-paint\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"H:\\Vue js\\Web-based-Paint\\front-end-paint\\node_modules\\vue-loader\\lib\\index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:CgoKCgoKCgoKCgojYXBwIHsKICBmb250LWZhbWlseTogQXZlbmlyLCBIZWx2ZXRpY2EsIEFyaWFsLCBzYW5zLXNlcmlmOwogIC13ZWJraXQtZm9udC1zbW9vdGhpbmc6IGFudGlhbGlhc2VkOwogIC1tb3otb3N4LWZvbnQtc21vb3RoaW5nOiBncmF5c2NhbGU7CiAgdGV4dC1hbGlnbjogY2VudGVyOwogIGNvbG9yOiAjMmMzZTUwOwp9CgojbmF2IHsKICBwYWRkaW5nOiAzMHB4Owp9CgojbmF2IGEgewogIGZvbnQtd2VpZ2h0OiBib2xkOwogIGNvbG9yOiAjMmMzZTUwOwp9CgojbmF2IGEucm91dGVyLWxpbmstZXhhY3QtYWN0aXZlIHsKICBjb2xvcjogIzQyYjk4MzsKfQo="},{"version":3,"sources":["App.vue"],"names":[],"mappings":";;;;;;;;;;;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA","file":"App.vue","sourceRoot":"src","sourcesContent":["<template>\n  <div id=\"app\">\n    <div id=\"container\">\n    <canvas id=\"canvas\" width=\"400\" height=\"300\"  v-bind:style=\"{cursor: selectedCursor}\">\n    This text is displayed if your browser does not support HTML5 Canvas.\n    </canvas>\n    </div>\n  </div>\n</template>\n\n<style>\n#app {\n  font-family: Avenir, Helvetica, Arial, sans-serif;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n  text-align: center;\n  color: #2c3e50;\n}\n\n#nav {\n  padding: 30px;\n}\n\n#nav a {\n  font-weight: bold;\n  color: #2c3e50;\n}\n\n#nav a.router-link-exact-active {\n  color: #42b983;\n}\n</style>\n<script>\nimport Rectangle from './models/Rectangle';\nexport default { \n  data() {\n        return {\n            shapes : [],\n            // Array to carry the selection handles (drag boxes) for each shape selection\n            selectionHandles: [],\n            // Hold canvas information\n            canvas: null,\n            ctx: null,\n            WIDTH: 0,\n            HEIGHT: 0,\n            // Interval at which the canvas is updated and redrawn again in milliseconds\n            INTERVAL: 20,\n            // Flags for current selection mode (drag the shape or resizing it)\n            isDrag: false,\n            isResizeDrag: false,\n            // The number of selection handle which the mouse is over it\n            expectResize: -1,\n            // Mouse Coordinates\n            mouse_x: 0, \n            mouse_y: 0,\n            // Redraw flag\n            // when set to true, the canvas will redraw everything\n            // invalidate() just sets this to false right now\n            // we want to call invalidate() whenever we make a change\n            canvasValid: false,\n            selectedShape: null,\n            // The following are the attributes of the selection border and corners\n            selectionColor: '#CC0000',\n            selectionWidth: 2,\n            selectionBoxColor: 'darkred', // New for selection boxes\n            selectionBoxSize: 6,\n            // Fake Canvas and CanvasContext \n            ghostcanvas: null,\n            gctx: null,\n            // since we can drag from anywhere in a node\n            // instead of just its x/y corner, we need to save\n            // the offset of the mouse when we start dragging.\n            offset_x: 0, \n            offset_y:0,\n            // Padding and border style widths for mouse offsets to maintain our calculations on click\n            stylePaddingLeft: 0, \n            stylePaddingTop: 0, \n            styleBorderLeft: 0, \n            styleBorderTop: 0,\n            selectedCursor: 'auto'\n        }\n    },\n    mounted() {\n      // Canvas initialization\n      this.canvas = document.getElementById('canvas');\n      this.HEIGHT = this.canvas.height;\n      this.WIDTH = this.canvas.width;\n      this.ctx = this.canvas.getContext('2d');\n      this.ghostcanvas = document.createElement('gcanvas');\n      this.ghostcanvas.height = this.HEIGHT;\n      this.ghostcanvas.width = this.WIDTH;\n      this.gctx = this.ghostcanvas.getContext('2d');\n      \n      //fixes a problem where double clicking causes text to get selected on the canvas\n      this.canvas.onselectstart = function () { return false; }\n      \n      // fixes mouse co-ordinate problems when there's a border or padding\n      // see getMouse for more detail\n      if (document.defaultView && document.defaultView.getComputedStyle) {\n        this.stylePaddingLeft = parseInt(document.defaultView.getComputedStyle(this.canvas, null)['paddingLeft'], 10)     || 0;\n        this.stylePaddingTop  = parseInt(document.defaultView.getComputedStyle(this.canvas, null)['paddingTop'], 10)      || 0;\n        this.styleBorderLeft  = parseInt(document.defaultView.getComputedStyle(this.canvas, null)['borderLeftWidth'], 10) || 0;\n        this.styleBorderTop   = parseInt(document.defaultView.getComputedStyle(this.canvas, null)['borderTopWidth'], 10)  || 0;\n      }\n      \n      // make mainDraw() fire every INTERVAL milliseconds\n      setInterval(this.mainDraw, this.INTERVAL);\n      \n      // set our events. Up and down are for dragging,\n      // double click is for making new boxes\n      this.canvas.onmousedown = this.mouseDown;\n      this.canvas.onmouseup = this.mouseUp;\n      this.canvas.ondblclick = this.addShape;\n      this.canvas.onmousemove = this.mouseMove;\n      \n      // set up the selection handle boxes\n      for (var i = 0; i < 8; i ++) {\n        var rect = new Rectangle;\n        this.selectionHandles.push(rect);\n      }\n      \n      // add custom initialization here:\n\n      \n      // add a large green rectangle\n      this.addRect(260, 70, 60, 65, 'rgba(0,205,0,0.7)');\n      \n      // add a green-blue rectangle\n      this.addRect(240, 120, 40, 40, 'rgba(2,165,165,0.7)');  \n      \n      // add a smaller purple rectangle\n      this.addRect(45, 60, 25, 25, 'rgba(150,150,250,0.7)');\n\n    },\n    methods: {\n        addRect(x, y, w, h, fill) {\n          var rect = new Rectangle;\n          rect.x = x;\n          rect.y = y;\n          rect.w = w\n          rect.h = h;\n          rect.fill = fill;\n          this.shapes.push(rect);\n          this.invalidate();\n      },\n      //wipes the canvas context\n      clear(c) {\n        c.clearRect(0, 0, this.WIDTH, this.HEIGHT);\n      },\n      // Main draw loop.\n      // While draw is called as often as the INTERVAL variable demands,\n      // It only ever does something if the canvas gets invalidated by our code\n      mainDraw() {\n        if (this.canvasValid == false) {\n          this.clear(this.ctx);\n          \n          // Add stuff you want drawn in the background all the time here\n          \n          // draw all boxes\n          var l = this.shapes.length;\n          for (var i = 0; i < l; i++) {\n            this.shapes[i].draw(this.ctx, this);\n          }\n          \n          // Add stuff you want drawn on top all the time here\n          \n          this.canvasValid = true;\n        }\n      },\n      // Happens when the mouse is moving inside the canvas\n      mouseMove(e){\n        if (this.isDrag) {\n          this.getMouse(e);\n          \n          this.selectedShape.x = this.mouse_x - this.offset_x;\n          this.selectedShape.y = this.mouse_y - this.offset_y;   \n          \n          // something is changing position so we better invalidate the canvas!\n          this.invalidate();\n        } else if (this.isResizeDrag) {\n          // time ro resize!\n          var oldx = this.selectedShape.x;\n          var oldy = this.selectedShape.y;\n          \n          // 0  1  2\n          // 3     4\n          // 5  6  7\n          switch (this.expectResize) {\n            case 0:\n              this.selectedShape.x = this.mouse_x;\n              this.selectedShape.y = this.mouse_y;\n              this.selectedShape.w += oldx - this.mouse_x;\n              this.selectedShape.h += oldy - this.mouse_y;\n              break;\n            case 1:\n              this.selectedShape.y = this.mouse_y;\n              this.selectedShape.h += oldy - this.mouse_y;\n              break;\n            case 2:\n              this.selectedShape.y = this.mouse_y;\n              this.selectedShape.w = this.mouse_x - oldx;\n              this.selectedShape.h += oldy - this.mouse_y;\n              break;\n            case 3:\n              this.selectedShape.x = this.mouse_x;\n              this.selectedShape.w += oldx - this.mouse_x;\n              break;\n            case 4:\n              this.selectedShape.w = this.mouse_x - oldx;\n              break;\n            case 5:\n              this.selectedShape.x = this.mouse_x;\n              this.selectedShape.w += oldx - this.mouse_x;\n              this.selectedShape.h = this.mouse_y - oldy;\n              break;\n            case 6:\n              this.selectedShape.h = this.mouse_y - oldy;\n              break;\n            case 7:\n              this.selectedShape.w = this.mouse_x - oldx;\n              this.selectedShape.h = this.mouse_y - oldy;\n              break;\n          }\n          \n          this.invalidate();\n        }\n        \n        this.getMouse(e);\n        // if there's a selection see if we grabbed one of the selection handles\n        if (this.selectedShape !== null && !this.isResizeDrag) {\n          for (var i = 0; i < 8; i++) {\n            // 0  1  2\n            // 3     4\n            // 5  6  7\n            \n            var cur = this.selectionHandles[i];\n            \n            // we dont need to use the ghost context because\n            // selection handles will always be rectangles\n            if (this.mouse_x >= cur.x && this.mouse_x <= cur.x + this.selectionBoxSize &&\n                this.mouse_y >= cur.y && this.mouse_y <= cur.y + this.selectionBoxSize) {\n              // we found one!\n              this.expectResize = i;\n              this.invalidate();\n              \n              switch (i) {\n                case 0:\n                  this.selectedCursor='nw-resize';\n                  break;\n                case 1:\n                  this.selectedCursor='n-resize';\n                  break;\n                case 2:\n                  this.selectedCursor='ne-resize';\n                  break;\n                case 3:\n                  this.selectedCursor='w-resize';\n                  break;\n                case 4:\n                  this.selectedCursor='e-resize';\n                  break;\n                case 5:\n                  this.selectedCursor='sw-resize';\n                  break;\n                case 6:\n                  this.selectedCursor='s-resize';\n                  break;\n                case 7:\n                  this.selectedCursor='se-resize';\n                  break;\n              }\n              return;\n            }\n            \n          }\n          // not over a selection box, return to normal\n          this.isResizeDrag = false;\n          this.expectResize = -1;\n          this.selectedCursor='auto';\n        }\n        \n      },\n      // Happens when the mouse is clicked in the canvas\n      mouseDown(e){\n        this.getMouse(e);\n        \n        //we are over a selection box\n        if (this.expectResize !== -1) {\n          this.isResizeDrag = true;\n          return;\n        }\n        \n        this.clear(this.gctx);\n        var l = this.shapes.length;\n        for (var i = l-1; i >= 0; i--) {\n          // draw shape onto ghost context\n          this.shapes[i].draw(this.gctx, 'black');\n          \n          // get image data at the mouse x,y pixel\n          var imageData = this.gctx.getImageData(this.mouse_x, this.mouse_y, 1, 1);\n          \n          // if the mouse pixel exists, select and break\n          if (imageData.data[3] > 0) {\n            this.selectedShape = this.shapes[i];\n            this.offset_x = this.mouse_x - this.selectedShape.x;\n            this.offset_y = this.mouse_y - this.selectedShape.y;\n            this.selectedShape.x = this.mouse_x - this.offset_x;\n            this.selectedShape.y = this.mouse_y - this.offset_y;\n            this.isDrag = true;\n            \n            this.invalidate();\n            this.clear(this.gctx);\n            return;\n          }\n          \n        }\n        // havent returned means we have selected nothing\n        this.selectedShape = null;\n        // clear the ghost canvas for next time\n        this.clear(this.gctx);\n        // invalidate because we might need the selection border to disappear\n        this.invalidate();\n      },\n      mouseUp(){\n        this.isDrag = false;\n        this.isResizeDrag = false;\n        this.expectResize = -1;\n      },\n      addShape(e) {\n        this.getMouse(e);\n        // Default size\n        var width = 20;\n        var height = 20;\n        this.addRect(this.mouse_x - (width / 2), this.mouse_y - (height / 2), width, height, 'rgba(220,205,65,0.7)');\n      },\n      invalidate() {\n        this.canvasValid = false;\n      },\n      // Sets mouse_x,mouse_y to the mouse position relative to the canvas\n      // unfortunately this can be tricky, we have to worry about padding and borders\n      getMouse(e) {\n            var element = this.canvas, offsetX = 0, offsetY = 0;\n\n            if (element.offsetParent) {\n              do {\n                offsetX += element.offsetLeft;\n                offsetY += element.offsetTop;\n              } while ((element = element.offsetParent));\n            }\n\n            // Add padding and border style widths to offset\n            offsetX += this.stylePaddingLeft;\n            offsetY += this.stylePaddingTop;\n\n            offsetX += this.styleBorderLeft;\n            offsetY += this.styleBorderTop;\n\n            this.mouse_x = e.pageX - offsetX;\n            this.mouse_y = e.pageY - offsetY\n      }\n    }\n}\n</script>"]}]}