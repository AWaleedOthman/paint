{"remainingRequest":"H:\\Vue js\\Web-based-Paint\\front-end-paint\\node_modules\\vue-loader\\lib\\index.js??vue-loader-options!H:\\Vue js\\Web-based-Paint\\front-end-paint\\src\\App.vue?vue&type=script&lang=js&","dependencies":[{"path":"H:\\Vue js\\Web-based-Paint\\front-end-paint\\src\\App.vue","mtime":1606487031748},{"path":"H:\\Vue js\\Web-based-Paint\\front-end-paint\\node_modules\\babel-loader\\lib\\index.js","mtime":315532800000},{"path":"H:\\Vue js\\Web-based-Paint\\front-end-paint\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"H:\\Vue js\\Web-based-Paint\\front-end-paint\\node_modules\\vue-loader\\lib\\index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:Ly8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KCmltcG9ydCBSZWN0YW5nbGUgZnJvbSAnLi9tb2RlbHMvUmV0Y3RhbmdsZS5qcyc7CmV4cG9ydCBkZWZhdWx0IHsgCiAgZGF0YSgpIHsKICAgICAgICByZXR1cm4gewogICAgICAgICAgICBzaGFwZXMgOiBbXSwKICAgICAgICAgICAgLy8gQXJyYXkgdG8gY2FycnkgdGhlIHNlbGVjdGlvbiBoYW5kbGVzIChkcmFnIGJveGVzKSBmb3IgZWFjaCBzaGFwZSBzZWxlY3Rpb24KICAgICAgICAgICAgc2VsZWN0aW9uSGFuZGxlczogW10sCiAgICAgICAgICAgIC8vIEhvbGQgY2FudmFzIGluZm9ybWF0aW9uCiAgICAgICAgICAgIGNhbnZhczogbnVsbCwKICAgICAgICAgICAgY3R4OiBudWxsLAogICAgICAgICAgICBXSURUSDogMCwKICAgICAgICAgICAgSEVJR0hUOiAwLAogICAgICAgICAgICAvLyBJbnRlcnZhbCBhdCB3aGljaCB0aGUgY2FudmFzIGlzIHVwZGF0ZWQgYW5kIHJlZHJhd24gYWdhaW4gaW4gbWlsbGlzZWNvbmRzCiAgICAgICAgICAgIElOVEVSVkFMOiAyMCwKICAgICAgICAgICAgLy8gRmxhZ3MgZm9yIGN1cnJlbnQgc2VsZWN0aW9uIG1vZGUgKGRyYWcgdGhlIHNoYXBlIG9yIHJlc2l6aW5nIGl0KQogICAgICAgICAgICBpc0RyYWc6IGZhbHNlLAogICAgICAgICAgICBpc1Jlc2l6ZURyYWc6IGZhbHNlLAogICAgICAgICAgICAvLyBUaGUgbnVtYmVyIG9mIHNlbGVjdGlvbiBoYW5kbGUgd2hpY2ggdGhlIG1vdXNlIGlzIG92ZXIgaXQKICAgICAgICAgICAgZXhwZWN0UmVzaXplOiAtMSwKICAgICAgICAgICAgLy8gTW91c2UgQ29vcmRpbmF0ZXMKICAgICAgICAgICAgbW91c2VfeDogMCwgCiAgICAgICAgICAgIG1vdXNlX3k6IDAsCiAgICAgICAgICAgIC8vIFJlZHJhdyBmbGFnCiAgICAgICAgICAgIC8vIHdoZW4gc2V0IHRvIHRydWUsIHRoZSBjYW52YXMgd2lsbCByZWRyYXcgZXZlcnl0aGluZwogICAgICAgICAgICAvLyBpbnZhbGlkYXRlKCkganVzdCBzZXRzIHRoaXMgdG8gZmFsc2UgcmlnaHQgbm93CiAgICAgICAgICAgIC8vIHdlIHdhbnQgdG8gY2FsbCBpbnZhbGlkYXRlKCkgd2hlbmV2ZXIgd2UgbWFrZSBhIGNoYW5nZQogICAgICAgICAgICBjYW52YXNWYWxpZDogZmFsc2UsCiAgICAgICAgICAgIHNlbGVjdGVkU2hhcGU6IG51bGwsCiAgICAgICAgICAgIC8vIFRoZSBmb2xsb3dpbmcgYXJlIHRoZSBhdHRyaWJ1dGVzIG9mIHRoZSBzZWxlY3Rpb24gYm9yZGVyIGFuZCBjb3JuZXJzCiAgICAgICAgICAgIHNlbGVjdGlvbkNvbG9yOiAnI0NDMDAwMCcsCiAgICAgICAgICAgIHNlbGVjdGlvbldpZHRoOiAyLAogICAgICAgICAgICBzZWxlY3Rpb25Cb3hDb2xvcjogJ2RhcmtyZWQnLCAvLyBOZXcgZm9yIHNlbGVjdGlvbiBib3hlcwogICAgICAgICAgICBzZWxlY3Rpb25Cb3hTaXplOiA2LAogICAgICAgICAgICAvLyBGYWtlIENhbnZhcyBhbmQgQ2FudmFzQ29udGV4dCAKICAgICAgICAgICAgZ2hvc3RjYW52YXM6IG51bGwsCiAgICAgICAgICAgIGdjdHg6IG51bGwsCiAgICAgICAgICAgIC8vIHNpbmNlIHdlIGNhbiBkcmFnIGZyb20gYW55d2hlcmUgaW4gYSBub2RlCiAgICAgICAgICAgIC8vIGluc3RlYWQgb2YganVzdCBpdHMgeC95IGNvcm5lciwgd2UgbmVlZCB0byBzYXZlCiAgICAgICAgICAgIC8vIHRoZSBvZmZzZXQgb2YgdGhlIG1vdXNlIHdoZW4gd2Ugc3RhcnQgZHJhZ2dpbmcuCiAgICAgICAgICAgIG9mZnNldF94OiAwLCAKICAgICAgICAgICAgb2Zmc2V0X3k6MCwKICAgICAgICAgICAgLy8gUGFkZGluZyBhbmQgYm9yZGVyIHN0eWxlIHdpZHRocyBmb3IgbW91c2Ugb2Zmc2V0cyB0byBtYWludGFpbiBvdXIgY2FsY3VsYXRpb25zIG9uIGNsaWNrCiAgICAgICAgICAgIHN0eWxlUGFkZGluZ0xlZnQ6IDAsIAogICAgICAgICAgICBzdHlsZVBhZGRpbmdUb3A6IDAsIAogICAgICAgICAgICBzdHlsZUJvcmRlckxlZnQ6IDAsIAogICAgICAgICAgICBzdHlsZUJvcmRlclRvcDogMCwKICAgICAgICAgICAgc2VsZWN0ZWRDdXJzb3I6ICdhdXRvJwogICAgICAgIH0KICAgIH0sCiAgICBtb3VudGVkKCkgewogICAgICAvLyBDYW52YXMgaW5pdGlhbGl6YXRpb24KICAgICAgY2FudmFzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NhbnZhcycpOwogICAgICBIRUlHSFQgPSBjYW52YXMuaGVpZ2h0OwogICAgICBXSURUSCA9IGNhbnZhcy53aWR0aDsKICAgICAgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7CiAgICAgIGdob3N0Y2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZ2NhbnZhcycpOwogICAgICBnaG9zdGNhbnZhcy5oZWlnaHQgPSBIRUlHSFQ7CiAgICAgIGdob3N0Y2FudmFzLndpZHRoID0gV0lEVEg7CiAgICAgIGdjdHggPSBnaG9zdGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpOwogICAgICAKICAgICAgLy9maXhlcyBhIHByb2JsZW0gd2hlcmUgZG91YmxlIGNsaWNraW5nIGNhdXNlcyB0ZXh0IHRvIGdldCBzZWxlY3RlZCBvbiB0aGUgY2FudmFzCiAgICAgIGNhbnZhcy5vbnNlbGVjdHN0YXJ0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZmFsc2U7IH0KICAgICAgCiAgICAgIC8vIGZpeGVzIG1vdXNlIGNvLW9yZGluYXRlIHByb2JsZW1zIHdoZW4gdGhlcmUncyBhIGJvcmRlciBvciBwYWRkaW5nCiAgICAgIC8vIHNlZSBnZXRNb3VzZSBmb3IgbW9yZSBkZXRhaWwKICAgICAgaWYgKGRvY3VtZW50LmRlZmF1bHRWaWV3ICYmIGRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUpIHsKICAgICAgICBzdHlsZVBhZGRpbmdMZWZ0ID0gcGFyc2VJbnQoZG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShjYW52YXMsIG51bGwpWydwYWRkaW5nTGVmdCddLCAxMCkgICAgIHx8IDA7CiAgICAgICAgc3R5bGVQYWRkaW5nVG9wICA9IHBhcnNlSW50KGRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUoY2FudmFzLCBudWxsKVsncGFkZGluZ1RvcCddLCAxMCkgICAgICB8fCAwOwogICAgICAgIHN0eWxlQm9yZGVyTGVmdCAgPSBwYXJzZUludChkb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKGNhbnZhcywgbnVsbClbJ2JvcmRlckxlZnRXaWR0aCddLCAxMCkgfHwgMDsKICAgICAgICBzdHlsZUJvcmRlclRvcCAgID0gcGFyc2VJbnQoZG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShjYW52YXMsIG51bGwpWydib3JkZXJUb3BXaWR0aCddLCAxMCkgIHx8IDA7CiAgICAgIH0KICAgICAgCiAgICAgIC8vIG1ha2UgbWFpbkRyYXcoKSBmaXJlIGV2ZXJ5IElOVEVSVkFMIG1pbGxpc2Vjb25kcwogICAgICBzZXRJbnRlcnZhbCh0aGlzLm1haW5EcmF3LCB0aGlzLklOVEVSVkFMKTsKICAgICAgCiAgICAgIC8vIHNldCBvdXIgZXZlbnRzLiBVcCBhbmQgZG93biBhcmUgZm9yIGRyYWdnaW5nLAogICAgICAvLyBkb3VibGUgY2xpY2sgaXMgZm9yIG1ha2luZyBuZXcgYm94ZXMKICAgICAgY2FudmFzLm9ubW91c2Vkb3duID0gdGhpcy5tb3VzZURvd247CiAgICAgIGNhbnZhcy5vbm1vdXNldXAgPSB0aGlzLm1vdXNlVXA7CiAgICAgIGNhbnZhcy5vbmRibGNsaWNrID0gdGhpcy5hZGRTaGFwZTsKICAgICAgY2FudmFzLm9ubW91c2Vtb3ZlID0gdGhpcy5tb3VzZU1vdmU7CiAgICAgIAogICAgICAvLyBzZXQgdXAgdGhlIHNlbGVjdGlvbiBoYW5kbGUgYm94ZXMKICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA4OyBpICsrKSB7CiAgICAgICAgdmFyIHJlY3QgPSBuZXcgUmVjdGFuZ2xlOwogICAgICAgIHNlbGVjdGlvbkhhbmRsZXMucHVzaChyZWN0KTsKICAgICAgfQogICAgICAKICAgICAgLy8gYWRkIGN1c3RvbSBpbml0aWFsaXphdGlvbiBoZXJlOgoKICAgICAgCiAgICAgIC8vIGFkZCBhIGxhcmdlIGdyZWVuIHJlY3RhbmdsZQogICAgICB0aGlzLmFkZFJlY3QoMjYwLCA3MCwgNjAsIDY1LCAncmdiYSgwLDIwNSwwLDAuNyknKTsKICAgICAgCiAgICAgIC8vIGFkZCBhIGdyZWVuLWJsdWUgcmVjdGFuZ2xlCiAgICAgIHRoaXMuYWRkUmVjdCgyNDAsIDEyMCwgNDAsIDQwLCAncmdiYSgyLDE2NSwxNjUsMC43KScpOyAgCiAgICAgIAogICAgICAvLyBhZGQgYSBzbWFsbGVyIHB1cnBsZSByZWN0YW5nbGUKICAgICAgdGhpcy5hZGRSZWN0KDQ1LCA2MCwgMjUsIDI1LCAncmdiYSgxNTAsMTUwLDI1MCwwLjcpJyk7CgogICAgfSwKICAgIG1ldGhvZHM6IHsKICAgICAgICBhZGRSZWN0KHgsIHksIHcsIGgsIGZpbGwpIHsKICAgICAgICAgIHZhciByZWN0ID0gbmV3IFJlY3RhbmdsZTsKICAgICAgICAgIHJlY3QueCA9IHg7CiAgICAgICAgICByZWN0LnkgPSB5OwogICAgICAgICAgcmVjdC53ID0gdwogICAgICAgICAgcmVjdC5oID0gaDsKICAgICAgICAgIHJlY3QuZmlsbCA9IGZpbGw7CiAgICAgICAgICB0aGlzLnNoYXBlcy5wdXNoKHJlY3QpOwogICAgICAgICAgdGhpcy5pbnZhbGlkYXRlKCk7CiAgICAgIH0sCiAgICAgIC8vd2lwZXMgdGhlIGNhbnZhcyBjb250ZXh0CiAgICAgIGNsZWFyKGMpIHsKICAgICAgICBjLmNsZWFyUmVjdCgwLCAwLCBXSURUSCwgSEVJR0hUKTsKICAgICAgfSwKICAgICAgLy8gTWFpbiBkcmF3IGxvb3AuCiAgICAgIC8vIFdoaWxlIGRyYXcgaXMgY2FsbGVkIGFzIG9mdGVuIGFzIHRoZSBJTlRFUlZBTCB2YXJpYWJsZSBkZW1hbmRzLAogICAgICAvLyBJdCBvbmx5IGV2ZXIgZG9lcyBzb21ldGhpbmcgaWYgdGhlIGNhbnZhcyBnZXRzIGludmFsaWRhdGVkIGJ5IG91ciBjb2RlCiAgICAgIG1haW5EcmF3KCkgewogICAgICAgIGlmIChjYW52YXNWYWxpZCA9PSBmYWxzZSkgewogICAgICAgICAgY2xlYXIoY3R4KTsKICAgICAgICAgIAogICAgICAgICAgLy8gQWRkIHN0dWZmIHlvdSB3YW50IGRyYXduIGluIHRoZSBiYWNrZ3JvdW5kIGFsbCB0aGUgdGltZSBoZXJlCiAgICAgICAgICAKICAgICAgICAgIC8vIGRyYXcgYWxsIGJveGVzCiAgICAgICAgICB2YXIgbCA9IHRoaXMuc2hhcGVzLmxlbmd0aDsKICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7CiAgICAgICAgICAgIHRoaXMuc2hhcGVzW2ldLmRyYXcoY3R4LCB0aGlzKTsKICAgICAgICAgIH0KICAgICAgICAgIAogICAgICAgICAgLy8gQWRkIHN0dWZmIHlvdSB3YW50IGRyYXduIG9uIHRvcCBhbGwgdGhlIHRpbWUgaGVyZQogICAgICAgICAgCiAgICAgICAgICBjYW52YXNWYWxpZCA9IHRydWU7CiAgICAgICAgfQogICAgICB9LAogICAgICAvLyBIYXBwZW5zIHdoZW4gdGhlIG1vdXNlIGlzIG1vdmluZyBpbnNpZGUgdGhlIGNhbnZhcwogICAgICBtb3VzZU1vdmUoZSl7CiAgICAgICAgaWYgKHRoaXMuaXNEcmFnKSB7CiAgICAgICAgICBnZXRNb3VzZShlKTsKICAgICAgICAgIAogICAgICAgICAgdGhpcy5zZWxlY3RlZFNoYXBlLnggPSB0aGlzLm1vdXNlX3ggLSB0aGlzLm9mZnNldF94OwogICAgICAgICAgdGhpcy5zZWxlY3RlZFNoYXBlLnkgPSB0aGlzLm1vdXNlX3kgLSB0aGlzLm9mZnNldF95OyAgIAogICAgICAgICAgCiAgICAgICAgICAvLyBzb21ldGhpbmcgaXMgY2hhbmdpbmcgcG9zaXRpb24gc28gd2UgYmV0dGVyIGludmFsaWRhdGUgdGhlIGNhbnZhcyEKICAgICAgICAgIHRoaXMuaW52YWxpZGF0ZSgpOwogICAgICAgIH0gZWxzZSBpZiAodGhpcy5pc1Jlc2l6ZURyYWcpIHsKICAgICAgICAgIC8vIHRpbWUgcm8gcmVzaXplIQogICAgICAgICAgdmFyIG9sZHggPSB0aGlzLnNlbGVjdGVkU2hhcGUueDsKICAgICAgICAgIHZhciBvbGR5ID0gdGhpcy5zZWxlY3RlZFNoYXBlLnk7CiAgICAgICAgICAKICAgICAgICAgIC8vIDAgIDEgIDIKICAgICAgICAgIC8vIDMgICAgIDQKICAgICAgICAgIC8vIDUgIDYgIDcKICAgICAgICAgIHN3aXRjaCAodGhpcy5leHBlY3RSZXNpemUpIHsKICAgICAgICAgICAgY2FzZSAwOgogICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRTaGFwZS54ID0gdGhpcy5tb3VzZV94OwogICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRTaGFwZS55ID0gdGhpcy5tb3VzZV95OwogICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRTaGFwZS53ICs9IG9sZHggLSB0aGlzLm1vdXNlX3g7CiAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZFNoYXBlLmggKz0gb2xkeSAtIHRoaXMubW91c2VfeTsKICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgY2FzZSAxOgogICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRTaGFwZS55ID0gdGhpcy5tb3VzZV95OwogICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRTaGFwZS5oICs9IG9sZHkgLSB0aGlzLm1vdXNlX3k7CiAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgIGNhc2UgMjoKICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkU2hhcGUueSA9IHRoaXMubW91c2VfeTsKICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkU2hhcGUudyA9IHRoaXMubW91c2VfeCAtIG9sZHg7CiAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZFNoYXBlLmggKz0gb2xkeSAtIHRoaXMubW91c2VfeTsKICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgY2FzZSAzOgogICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRTaGFwZS54ID0gdGhpcy5tb3VzZV94OwogICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRTaGFwZS53ICs9IG9sZHggLSB0aGlzLm1vdXNlX3g7CiAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgIGNhc2UgNDoKICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkU2hhcGUudyA9IHRoaXMubW91c2VfeCAtIG9sZHg7CiAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgIGNhc2UgNToKICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkU2hhcGUueCA9IHRoaXMubW91c2VfeDsKICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkU2hhcGUudyArPSBvbGR4IC0gdGhpcy5tb3VzZV94OwogICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRTaGFwZS5oID0gdGhpcy5tb3VzZV95IC0gb2xkeTsKICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgY2FzZSA2OgogICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRTaGFwZS5oID0gdGhpcy5tb3VzZV95IC0gb2xkeTsKICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgY2FzZSA3OgogICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRTaGFwZS53ID0gdGhpcy5tb3VzZV94IC0gb2xkeDsKICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkU2hhcGUuaCA9IHRoaXMubW91c2VfeSAtIG9sZHk7CiAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICB9CiAgICAgICAgICAKICAgICAgICAgIHRoaXMuaW52YWxpZGF0ZSgpOwogICAgICAgIH0KICAgICAgICAKICAgICAgICB0aGlzLmdldE1vdXNlKGUpOwogICAgICAgIC8vIGlmIHRoZXJlJ3MgYSBzZWxlY3Rpb24gc2VlIGlmIHdlIGdyYWJiZWQgb25lIG9mIHRoZSBzZWxlY3Rpb24gaGFuZGxlcwogICAgICAgIGlmICh0aGlzLnNlbGVjdGVkU2hhcGUgIT09IG51bGwgJiYgIXRoaXMuaXNSZXNpemVEcmFnKSB7CiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDg7IGkrKykgewogICAgICAgICAgICAvLyAwICAxICAyCiAgICAgICAgICAgIC8vIDMgICAgIDQKICAgICAgICAgICAgLy8gNSAgNiAgNwogICAgICAgICAgICAKICAgICAgICAgICAgdmFyIGN1ciA9IHRoaXMuc2VsZWN0aW9uSGFuZGxlc1tpXTsKICAgICAgICAgICAgCiAgICAgICAgICAgIC8vIHdlIGRvbnQgbmVlZCB0byB1c2UgdGhlIGdob3N0IGNvbnRleHQgYmVjYXVzZQogICAgICAgICAgICAvLyBzZWxlY3Rpb24gaGFuZGxlcyB3aWxsIGFsd2F5cyBiZSByZWN0YW5nbGVzCiAgICAgICAgICAgIGlmIChteCA+PSBjdXIueCAmJiBteCA8PSBjdXIueCArIHRoaXMuc2VsZWN0aW9uQm94U2l6ZSAmJgogICAgICAgICAgICAgICAgbXkgPj0gY3VyLnkgJiYgbXkgPD0gY3VyLnkgKyB0aGlzLnNlbGVjdGlvbkJveFNpemUpIHsKICAgICAgICAgICAgICAvLyB3ZSBmb3VuZCBvbmUhCiAgICAgICAgICAgICAgdGhpcy5leHBlY3RSZXNpemUgPSBpOwogICAgICAgICAgICAgIHRoaXMuaW52YWxpZGF0ZSgpOwogICAgICAgICAgICAgIAogICAgICAgICAgICAgIHN3aXRjaCAoaSkgewogICAgICAgICAgICAgICAgY2FzZSAwOgogICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkQ3Vyc29yPSdudy1yZXNpemUnOwogICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgIGNhc2UgMToKICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZEN1cnNvcj0nbi1yZXNpemUnOwogICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgIGNhc2UgMjoKICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZEN1cnNvcj0nbmUtcmVzaXplJzsKICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICBjYXNlIDM6CiAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRDdXJzb3I9J3ctcmVzaXplJzsKICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICBjYXNlIDQ6CiAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRDdXJzb3I9J2UtcmVzaXplJzsKICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICBjYXNlIDU6CiAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRDdXJzb3I9J3N3LXJlc2l6ZSc7CiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgY2FzZSA2OgogICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkQ3Vyc29yPSdzLXJlc2l6ZSc7CiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgY2FzZSA3OgogICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkQ3Vyc29yPSdzZS1yZXNpemUnOwogICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgcmV0dXJuOwogICAgICAgICAgICB9CiAgICAgICAgICAgIAogICAgICAgICAgfQogICAgICAgICAgLy8gbm90IG92ZXIgYSBzZWxlY3Rpb24gYm94LCByZXR1cm4gdG8gbm9ybWFsCiAgICAgICAgICB0aGlzLmlzUmVzaXplRHJhZyA9IGZhbHNlOwogICAgICAgICAgdGhpcy5leHBlY3RSZXNpemUgPSAtMTsKICAgICAgICAgIHRoaXMuc2VsZWN0ZWRDdXJzb3I9J2F1dG8nOwogICAgICAgIH0KICAgICAgICAKICAgICAgfSwKICAgICAgLy8gSGFwcGVucyB3aGVuIHRoZSBtb3VzZSBpcyBjbGlja2VkIGluIHRoZSBjYW52YXMKICAgICAgbW91c2VEb3duKGUpewogICAgICAgIHRoaXMuZ2V0TW91c2UoZSk7CiAgICAgICAgCiAgICAgICAgLy93ZSBhcmUgb3ZlciBhIHNlbGVjdGlvbiBib3gKICAgICAgICBpZiAodGhpcy5leHBlY3RSZXNpemUgIT09IC0xKSB7CiAgICAgICAgICB0aGlzLmlzUmVzaXplRHJhZyA9IHRydWU7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIAogICAgICAgIHRoaXMuY2xlYXIodGhpcy5nY3R4KTsKICAgICAgICB2YXIgbCA9IHRoaXMuc2hhcGVzLmxlbmd0aDsKICAgICAgICBmb3IgKHZhciBpID0gbC0xOyBpID49IDA7IGktLSkgewogICAgICAgICAgLy8gZHJhdyBzaGFwZSBvbnRvIGdob3N0IGNvbnRleHQKICAgICAgICAgIHRoaXMuc2hhcGVzW2ldLmRyYXcoZ2N0eCwgJ2JsYWNrJyk7CiAgICAgICAgICAKICAgICAgICAgIC8vIGdldCBpbWFnZSBkYXRhIGF0IHRoZSBtb3VzZSB4LHkgcGl4ZWwKICAgICAgICAgIHZhciBpbWFnZURhdGEgPSB0aGlzLmdjdHguZ2V0SW1hZ2VEYXRhKG14LCBteSwgMSwgMSk7CiAgICAgICAgICB2YXIgaW5kZXggPSAodGhpcy5tb3VzZV94ICsgdGhpcy5tb3VzZV95ICogaW1hZ2VEYXRhLndpZHRoKSAqIDQ7CiAgICAgICAgICAKICAgICAgICAgIC8vIGlmIHRoZSBtb3VzZSBwaXhlbCBleGlzdHMsIHNlbGVjdCBhbmQgYnJlYWsKICAgICAgICAgIGlmIChpbWFnZURhdGEuZGF0YVszXSA+IDApIHsKICAgICAgICAgICAgdGhpcy5zZWxlY3RlZFNoYXBlID0gdGhpcy5zaGFwZXNbaV07CiAgICAgICAgICAgIHRoaXMub2Zmc2V0X3ggPSB0aGlzLm1vdXNlX3ggLSB0aGlzLnNlbGVjdGVkU2hhcGUueDsKICAgICAgICAgICAgdGhpcy5vZmZzZXRfeSA9IHRoaXMubW91c2VfeSAtIHRoaXMuc2VsZWN0ZWRTaGFwZS55OwogICAgICAgICAgICB0aGlzLnNlbGVjdGVkU2hhcGUueCA9IHRoaXMubW91c2VfeCAtIHRoaXMub2Zmc2V0X3g7CiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRTaGFwZS55ID0gdGhpcy5tb3VzZV95IC0gdGhpcy5vZmZzZXRfeTsKICAgICAgICAgICAgdGhpcy5pc0RyYWcgPSB0cnVlOwogICAgICAgICAgICAKICAgICAgICAgICAgdGhpcy5pbnZhbGlkYXRlKCk7CiAgICAgICAgICAgIHRoaXMuY2xlYXIodGhpcy5nY3R4KTsKICAgICAgICAgICAgcmV0dXJuOwogICAgICAgICAgfQogICAgICAgICAgCiAgICAgICAgfQogICAgICAgIC8vIGhhdmVudCByZXR1cm5lZCBtZWFucyB3ZSBoYXZlIHNlbGVjdGVkIG5vdGhpbmcKICAgICAgICB0aGlzLnNlbGVjdGVkU2hhcGUgPSBudWxsOwogICAgICAgIC8vIGNsZWFyIHRoZSBnaG9zdCBjYW52YXMgZm9yIG5leHQgdGltZQogICAgICAgIHRoaXMuY2xlYXIodGhpcy5nY3R4KTsKICAgICAgICAvLyBpbnZhbGlkYXRlIGJlY2F1c2Ugd2UgbWlnaHQgbmVlZCB0aGUgc2VsZWN0aW9uIGJvcmRlciB0byBkaXNhcHBlYXIKICAgICAgICB0aGlzLmludmFsaWRhdGUoKTsKICAgICAgfSwKICAgICAgbW91c2VVcCgpewogICAgICAgIHRoaXMuaXNEcmFnID0gZmFsc2U7CiAgICAgICAgdGhpcy5pc1Jlc2l6ZURyYWcgPSBmYWxzZTsKICAgICAgICB0aGlzLmV4cGVjdFJlc2l6ZSA9IC0xOwogICAgICB9LAogICAgICBhZGRTaGFwZShlKSB7CiAgICAgICAgdGhpcy5nZXRNb3VzZShlKTsKICAgICAgICAvLyBEZWZhdWx0IHNpemUKICAgICAgICB2YXIgd2lkdGggPSAyMDsKICAgICAgICB2YXIgaGVpZ2h0ID0gMjA7CiAgICAgICAgdGhpcy5hZGRSZWN0KHRoaXMubW91c2VfeCAtICh3aWR0aCAvIDIpLCB0aGlzLm1vdXNlX3kgLSAoaGVpZ2h0IC8gMiksIHdpZHRoLCBoZWlnaHQsICdyZ2JhKDIyMCwyMDUsNjUsMC43KScpOwogICAgICB9LAogICAgICBpbnZhbGlkYXRlKCkgewogICAgICAgIHRoaXMuY2FudmFzVmFsaWQgPSBmYWxzZTsKICAgICAgfSwKICAgICAgLy8gU2V0cyBtb3VzZV94LG1vdXNlX3kgdG8gdGhlIG1vdXNlIHBvc2l0aW9uIHJlbGF0aXZlIHRvIHRoZSBjYW52YXMKICAgICAgLy8gdW5mb3J0dW5hdGVseSB0aGlzIGNhbiBiZSB0cmlja3ksIHdlIGhhdmUgdG8gd29ycnkgYWJvdXQgcGFkZGluZyBhbmQgYm9yZGVycwogICAgICBnZXRNb3VzZShlKSB7CiAgICAgICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5jYW52YXMsIG9mZnNldFggPSAwLCBvZmZzZXRZID0gMDsKCiAgICAgICAgICAgIGlmIChlbGVtZW50Lm9mZnNldFBhcmVudCkgewogICAgICAgICAgICAgIGRvIHsKICAgICAgICAgICAgICAgIG9mZnNldFggKz0gZWxlbWVudC5vZmZzZXRMZWZ0OwogICAgICAgICAgICAgICAgb2Zmc2V0WSArPSBlbGVtZW50Lm9mZnNldFRvcDsKICAgICAgICAgICAgICB9IHdoaWxlICgoZWxlbWVudCA9IGVsZW1lbnQub2Zmc2V0UGFyZW50KSk7CiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIC8vIEFkZCBwYWRkaW5nIGFuZCBib3JkZXIgc3R5bGUgd2lkdGhzIHRvIG9mZnNldAogICAgICAgICAgICBvZmZzZXRYICs9IHRoaXMuc3R5bGVQYWRkaW5nTGVmdDsKICAgICAgICAgICAgb2Zmc2V0WSArPSB0aGlzLnN0eWxlUGFkZGluZ1RvcDsKCiAgICAgICAgICAgIG9mZnNldFggKz0gdGhpcy5zdHlsZUJvcmRlckxlZnQ7CiAgICAgICAgICAgIG9mZnNldFkgKz0gdGhpcy5zdHlsZUJvcmRlclRvcDsKCiAgICAgICAgICAgIHRoaXMubW91c2VfeCA9IGUucGFnZVggLSB0aGlzLm9mZnNldF94OwogICAgICAgICAgICB0aGlzLm1vdXNlX3kgPSBlLnBhZ2VZIC0gdGhpcy5vZmZzZXRfeQogICAgICB9CiAgICB9Cn0K"},{"version":3,"sources":["App.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAkCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA","file":"App.vue","sourceRoot":"src","sourcesContent":["<template>\n  <div id=\"app\">\n    <div id=\"container\">\n    <canvas id=\"canvas\" width=\"400\" height=\"300\"  v-bind:style=\"{cursor: selectedCursor}\">\n    This text is displayed if your browser does not support HTML5 Canvas.\n    </canvas>\n    </div>\n    <div style=\"font-family: Verdana; font-size: 12px;\">\n  </div>\n</template>\n\n<style>\n#app {\n  font-family: Avenir, Helvetica, Arial, sans-serif;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n  text-align: center;\n  color: #2c3e50;\n}\n\n#nav {\n  padding: 30px;\n}\n\n#nav a {\n  font-weight: bold;\n  color: #2c3e50;\n}\n\n#nav a.router-link-exact-active {\n  color: #42b983;\n}\n</style>\n<script>\nimport Rectangle from './models/Retctangle.js';\nexport default { \n  data() {\n        return {\n            shapes : [],\n            // Array to carry the selection handles (drag boxes) for each shape selection\n            selectionHandles: [],\n            // Hold canvas information\n            canvas: null,\n            ctx: null,\n            WIDTH: 0,\n            HEIGHT: 0,\n            // Interval at which the canvas is updated and redrawn again in milliseconds\n            INTERVAL: 20,\n            // Flags for current selection mode (drag the shape or resizing it)\n            isDrag: false,\n            isResizeDrag: false,\n            // The number of selection handle which the mouse is over it\n            expectResize: -1,\n            // Mouse Coordinates\n            mouse_x: 0, \n            mouse_y: 0,\n            // Redraw flag\n            // when set to true, the canvas will redraw everything\n            // invalidate() just sets this to false right now\n            // we want to call invalidate() whenever we make a change\n            canvasValid: false,\n            selectedShape: null,\n            // The following are the attributes of the selection border and corners\n            selectionColor: '#CC0000',\n            selectionWidth: 2,\n            selectionBoxColor: 'darkred', // New for selection boxes\n            selectionBoxSize: 6,\n            // Fake Canvas and CanvasContext \n            ghostcanvas: null,\n            gctx: null,\n            // since we can drag from anywhere in a node\n            // instead of just its x/y corner, we need to save\n            // the offset of the mouse when we start dragging.\n            offset_x: 0, \n            offset_y:0,\n            // Padding and border style widths for mouse offsets to maintain our calculations on click\n            stylePaddingLeft: 0, \n            stylePaddingTop: 0, \n            styleBorderLeft: 0, \n            styleBorderTop: 0,\n            selectedCursor: 'auto'\n        }\n    },\n    mounted() {\n      // Canvas initialization\n      canvas = document.getElementById('canvas');\n      HEIGHT = canvas.height;\n      WIDTH = canvas.width;\n      ctx = canvas.getContext('2d');\n      ghostcanvas = document.createElement('gcanvas');\n      ghostcanvas.height = HEIGHT;\n      ghostcanvas.width = WIDTH;\n      gctx = ghostcanvas.getContext('2d');\n      \n      //fixes a problem where double clicking causes text to get selected on the canvas\n      canvas.onselectstart = function () { return false; }\n      \n      // fixes mouse co-ordinate problems when there's a border or padding\n      // see getMouse for more detail\n      if (document.defaultView && document.defaultView.getComputedStyle) {\n        stylePaddingLeft = parseInt(document.defaultView.getComputedStyle(canvas, null)['paddingLeft'], 10)     || 0;\n        stylePaddingTop  = parseInt(document.defaultView.getComputedStyle(canvas, null)['paddingTop'], 10)      || 0;\n        styleBorderLeft  = parseInt(document.defaultView.getComputedStyle(canvas, null)['borderLeftWidth'], 10) || 0;\n        styleBorderTop   = parseInt(document.defaultView.getComputedStyle(canvas, null)['borderTopWidth'], 10)  || 0;\n      }\n      \n      // make mainDraw() fire every INTERVAL milliseconds\n      setInterval(this.mainDraw, this.INTERVAL);\n      \n      // set our events. Up and down are for dragging,\n      // double click is for making new boxes\n      canvas.onmousedown = this.mouseDown;\n      canvas.onmouseup = this.mouseUp;\n      canvas.ondblclick = this.addShape;\n      canvas.onmousemove = this.mouseMove;\n      \n      // set up the selection handle boxes\n      for (var i = 0; i < 8; i ++) {\n        var rect = new Rectangle;\n        selectionHandles.push(rect);\n      }\n      \n      // add custom initialization here:\n\n      \n      // add a large green rectangle\n      this.addRect(260, 70, 60, 65, 'rgba(0,205,0,0.7)');\n      \n      // add a green-blue rectangle\n      this.addRect(240, 120, 40, 40, 'rgba(2,165,165,0.7)');  \n      \n      // add a smaller purple rectangle\n      this.addRect(45, 60, 25, 25, 'rgba(150,150,250,0.7)');\n\n    },\n    methods: {\n        addRect(x, y, w, h, fill) {\n          var rect = new Rectangle;\n          rect.x = x;\n          rect.y = y;\n          rect.w = w\n          rect.h = h;\n          rect.fill = fill;\n          this.shapes.push(rect);\n          this.invalidate();\n      },\n      //wipes the canvas context\n      clear(c) {\n        c.clearRect(0, 0, WIDTH, HEIGHT);\n      },\n      // Main draw loop.\n      // While draw is called as often as the INTERVAL variable demands,\n      // It only ever does something if the canvas gets invalidated by our code\n      mainDraw() {\n        if (canvasValid == false) {\n          clear(ctx);\n          \n          // Add stuff you want drawn in the background all the time here\n          \n          // draw all boxes\n          var l = this.shapes.length;\n          for (var i = 0; i < l; i++) {\n            this.shapes[i].draw(ctx, this);\n          }\n          \n          // Add stuff you want drawn on top all the time here\n          \n          canvasValid = true;\n        }\n      },\n      // Happens when the mouse is moving inside the canvas\n      mouseMove(e){\n        if (this.isDrag) {\n          getMouse(e);\n          \n          this.selectedShape.x = this.mouse_x - this.offset_x;\n          this.selectedShape.y = this.mouse_y - this.offset_y;   \n          \n          // something is changing position so we better invalidate the canvas!\n          this.invalidate();\n        } else if (this.isResizeDrag) {\n          // time ro resize!\n          var oldx = this.selectedShape.x;\n          var oldy = this.selectedShape.y;\n          \n          // 0  1  2\n          // 3     4\n          // 5  6  7\n          switch (this.expectResize) {\n            case 0:\n              this.selectedShape.x = this.mouse_x;\n              this.selectedShape.y = this.mouse_y;\n              this.selectedShape.w += oldx - this.mouse_x;\n              this.selectedShape.h += oldy - this.mouse_y;\n              break;\n            case 1:\n              this.selectedShape.y = this.mouse_y;\n              this.selectedShape.h += oldy - this.mouse_y;\n              break;\n            case 2:\n              this.selectedShape.y = this.mouse_y;\n              this.selectedShape.w = this.mouse_x - oldx;\n              this.selectedShape.h += oldy - this.mouse_y;\n              break;\n            case 3:\n              this.selectedShape.x = this.mouse_x;\n              this.selectedShape.w += oldx - this.mouse_x;\n              break;\n            case 4:\n              this.selectedShape.w = this.mouse_x - oldx;\n              break;\n            case 5:\n              this.selectedShape.x = this.mouse_x;\n              this.selectedShape.w += oldx - this.mouse_x;\n              this.selectedShape.h = this.mouse_y - oldy;\n              break;\n            case 6:\n              this.selectedShape.h = this.mouse_y - oldy;\n              break;\n            case 7:\n              this.selectedShape.w = this.mouse_x - oldx;\n              this.selectedShape.h = this.mouse_y - oldy;\n              break;\n          }\n          \n          this.invalidate();\n        }\n        \n        this.getMouse(e);\n        // if there's a selection see if we grabbed one of the selection handles\n        if (this.selectedShape !== null && !this.isResizeDrag) {\n          for (var i = 0; i < 8; i++) {\n            // 0  1  2\n            // 3     4\n            // 5  6  7\n            \n            var cur = this.selectionHandles[i];\n            \n            // we dont need to use the ghost context because\n            // selection handles will always be rectangles\n            if (mx >= cur.x && mx <= cur.x + this.selectionBoxSize &&\n                my >= cur.y && my <= cur.y + this.selectionBoxSize) {\n              // we found one!\n              this.expectResize = i;\n              this.invalidate();\n              \n              switch (i) {\n                case 0:\n                  this.selectedCursor='nw-resize';\n                  break;\n                case 1:\n                  this.selectedCursor='n-resize';\n                  break;\n                case 2:\n                  this.selectedCursor='ne-resize';\n                  break;\n                case 3:\n                  this.selectedCursor='w-resize';\n                  break;\n                case 4:\n                  this.selectedCursor='e-resize';\n                  break;\n                case 5:\n                  this.selectedCursor='sw-resize';\n                  break;\n                case 6:\n                  this.selectedCursor='s-resize';\n                  break;\n                case 7:\n                  this.selectedCursor='se-resize';\n                  break;\n              }\n              return;\n            }\n            \n          }\n          // not over a selection box, return to normal\n          this.isResizeDrag = false;\n          this.expectResize = -1;\n          this.selectedCursor='auto';\n        }\n        \n      },\n      // Happens when the mouse is clicked in the canvas\n      mouseDown(e){\n        this.getMouse(e);\n        \n        //we are over a selection box\n        if (this.expectResize !== -1) {\n          this.isResizeDrag = true;\n          return;\n        }\n        \n        this.clear(this.gctx);\n        var l = this.shapes.length;\n        for (var i = l-1; i >= 0; i--) {\n          // draw shape onto ghost context\n          this.shapes[i].draw(gctx, 'black');\n          \n          // get image data at the mouse x,y pixel\n          var imageData = this.gctx.getImageData(mx, my, 1, 1);\n          var index = (this.mouse_x + this.mouse_y * imageData.width) * 4;\n          \n          // if the mouse pixel exists, select and break\n          if (imageData.data[3] > 0) {\n            this.selectedShape = this.shapes[i];\n            this.offset_x = this.mouse_x - this.selectedShape.x;\n            this.offset_y = this.mouse_y - this.selectedShape.y;\n            this.selectedShape.x = this.mouse_x - this.offset_x;\n            this.selectedShape.y = this.mouse_y - this.offset_y;\n            this.isDrag = true;\n            \n            this.invalidate();\n            this.clear(this.gctx);\n            return;\n          }\n          \n        }\n        // havent returned means we have selected nothing\n        this.selectedShape = null;\n        // clear the ghost canvas for next time\n        this.clear(this.gctx);\n        // invalidate because we might need the selection border to disappear\n        this.invalidate();\n      },\n      mouseUp(){\n        this.isDrag = false;\n        this.isResizeDrag = false;\n        this.expectResize = -1;\n      },\n      addShape(e) {\n        this.getMouse(e);\n        // Default size\n        var width = 20;\n        var height = 20;\n        this.addRect(this.mouse_x - (width / 2), this.mouse_y - (height / 2), width, height, 'rgba(220,205,65,0.7)');\n      },\n      invalidate() {\n        this.canvasValid = false;\n      },\n      // Sets mouse_x,mouse_y to the mouse position relative to the canvas\n      // unfortunately this can be tricky, we have to worry about padding and borders\n      getMouse(e) {\n            var element = this.canvas, offsetX = 0, offsetY = 0;\n\n            if (element.offsetParent) {\n              do {\n                offsetX += element.offsetLeft;\n                offsetY += element.offsetTop;\n              } while ((element = element.offsetParent));\n            }\n\n            // Add padding and border style widths to offset\n            offsetX += this.stylePaddingLeft;\n            offsetY += this.stylePaddingTop;\n\n            offsetX += this.styleBorderLeft;\n            offsetY += this.styleBorderTop;\n\n            this.mouse_x = e.pageX - this.offset_x;\n            this.mouse_y = e.pageY - this.offset_y\n      }\n    }\n}\n</script>"]}]}