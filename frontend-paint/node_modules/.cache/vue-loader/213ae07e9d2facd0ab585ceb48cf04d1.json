{"remainingRequest":"H:\\Vue js\\Web-based-Paint\\front-end-paint\\node_modules\\vue-loader\\lib\\index.js??vue-loader-options!H:\\Vue js\\Web-based-Paint\\front-end-paint\\src\\App.vue?vue&type=script&lang=js&","dependencies":[{"path":"H:\\Vue js\\Web-based-Paint\\front-end-paint\\src\\App.vue","mtime":1606488245290},{"path":"H:\\Vue js\\Web-based-Paint\\front-end-paint\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"H:\\Vue js\\Web-based-Paint\\front-end-paint\\node_modules\\babel-loader\\lib\\index.js","mtime":315532800000},{"path":"H:\\Vue js\\Web-based-Paint\\front-end-paint\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"H:\\Vue js\\Web-based-Paint\\front-end-paint\\node_modules\\vue-loader\\lib\\index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:Ly8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KCmltcG9ydCBSZWN0YW5nbGUgZnJvbSAnLi9tb2RlbHMvUmVjdGFuZ2xlJzsKZXhwb3J0IGRlZmF1bHQgeyAKICBkYXRhKCkgewogICAgICAgIHJldHVybiB7CiAgICAgICAgICAgIHNoYXBlcyA6IFtdLAogICAgICAgICAgICAvLyBBcnJheSB0byBjYXJyeSB0aGUgc2VsZWN0aW9uIGhhbmRsZXMgKGRyYWcgYm94ZXMpIGZvciBlYWNoIHNoYXBlIHNlbGVjdGlvbgogICAgICAgICAgICBzZWxlY3Rpb25IYW5kbGVzOiBbXSwKICAgICAgICAgICAgLy8gSG9sZCBjYW52YXMgaW5mb3JtYXRpb24KICAgICAgICAgICAgY2FudmFzOiBudWxsLAogICAgICAgICAgICBjdHg6IG51bGwsCiAgICAgICAgICAgIFdJRFRIOiAwLAogICAgICAgICAgICBIRUlHSFQ6IDAsCiAgICAgICAgICAgIC8vIEludGVydmFsIGF0IHdoaWNoIHRoZSBjYW52YXMgaXMgdXBkYXRlZCBhbmQgcmVkcmF3biBhZ2FpbiBpbiBtaWxsaXNlY29uZHMKICAgICAgICAgICAgSU5URVJWQUw6IDIwLAogICAgICAgICAgICAvLyBGbGFncyBmb3IgY3VycmVudCBzZWxlY3Rpb24gbW9kZSAoZHJhZyB0aGUgc2hhcGUgb3IgcmVzaXppbmcgaXQpCiAgICAgICAgICAgIGlzRHJhZzogZmFsc2UsCiAgICAgICAgICAgIGlzUmVzaXplRHJhZzogZmFsc2UsCiAgICAgICAgICAgIC8vIFRoZSBudW1iZXIgb2Ygc2VsZWN0aW9uIGhhbmRsZSB3aGljaCB0aGUgbW91c2UgaXMgb3ZlciBpdAogICAgICAgICAgICBleHBlY3RSZXNpemU6IC0xLAogICAgICAgICAgICAvLyBNb3VzZSBDb29yZGluYXRlcwogICAgICAgICAgICBtb3VzZV94OiAwLCAKICAgICAgICAgICAgbW91c2VfeTogMCwKICAgICAgICAgICAgLy8gUmVkcmF3IGZsYWcKICAgICAgICAgICAgLy8gd2hlbiBzZXQgdG8gdHJ1ZSwgdGhlIGNhbnZhcyB3aWxsIHJlZHJhdyBldmVyeXRoaW5nCiAgICAgICAgICAgIC8vIGludmFsaWRhdGUoKSBqdXN0IHNldHMgdGhpcyB0byBmYWxzZSByaWdodCBub3cKICAgICAgICAgICAgLy8gd2Ugd2FudCB0byBjYWxsIGludmFsaWRhdGUoKSB3aGVuZXZlciB3ZSBtYWtlIGEgY2hhbmdlCiAgICAgICAgICAgIGNhbnZhc1ZhbGlkOiBmYWxzZSwKICAgICAgICAgICAgc2VsZWN0ZWRTaGFwZTogbnVsbCwKICAgICAgICAgICAgLy8gVGhlIGZvbGxvd2luZyBhcmUgdGhlIGF0dHJpYnV0ZXMgb2YgdGhlIHNlbGVjdGlvbiBib3JkZXIgYW5kIGNvcm5lcnMKICAgICAgICAgICAgc2VsZWN0aW9uQ29sb3I6ICcjQ0MwMDAwJywKICAgICAgICAgICAgc2VsZWN0aW9uV2lkdGg6IDIsCiAgICAgICAgICAgIHNlbGVjdGlvbkJveENvbG9yOiAnZGFya3JlZCcsIC8vIE5ldyBmb3Igc2VsZWN0aW9uIGJveGVzCiAgICAgICAgICAgIHNlbGVjdGlvbkJveFNpemU6IDYsCiAgICAgICAgICAgIC8vIEZha2UgQ2FudmFzIGFuZCBDYW52YXNDb250ZXh0IAogICAgICAgICAgICBnaG9zdGNhbnZhczogbnVsbCwKICAgICAgICAgICAgZ2N0eDogbnVsbCwKICAgICAgICAgICAgLy8gc2luY2Ugd2UgY2FuIGRyYWcgZnJvbSBhbnl3aGVyZSBpbiBhIG5vZGUKICAgICAgICAgICAgLy8gaW5zdGVhZCBvZiBqdXN0IGl0cyB4L3kgY29ybmVyLCB3ZSBuZWVkIHRvIHNhdmUKICAgICAgICAgICAgLy8gdGhlIG9mZnNldCBvZiB0aGUgbW91c2Ugd2hlbiB3ZSBzdGFydCBkcmFnZ2luZy4KICAgICAgICAgICAgb2Zmc2V0X3g6IDAsIAogICAgICAgICAgICBvZmZzZXRfeTowLAogICAgICAgICAgICAvLyBQYWRkaW5nIGFuZCBib3JkZXIgc3R5bGUgd2lkdGhzIGZvciBtb3VzZSBvZmZzZXRzIHRvIG1haW50YWluIG91ciBjYWxjdWxhdGlvbnMgb24gY2xpY2sKICAgICAgICAgICAgc3R5bGVQYWRkaW5nTGVmdDogMCwgCiAgICAgICAgICAgIHN0eWxlUGFkZGluZ1RvcDogMCwgCiAgICAgICAgICAgIHN0eWxlQm9yZGVyTGVmdDogMCwgCiAgICAgICAgICAgIHN0eWxlQm9yZGVyVG9wOiAwLAogICAgICAgICAgICBzZWxlY3RlZEN1cnNvcjogJ2F1dG8nCiAgICAgICAgfQogICAgfSwKICAgIG1vdW50ZWQoKSB7CiAgICAgIC8vIENhbnZhcyBpbml0aWFsaXphdGlvbgogICAgICB0aGlzLmNhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjYW52YXMnKTsKICAgICAgdGhpcy5IRUlHSFQgPSB0aGlzLmNhbnZhcy5oZWlnaHQ7CiAgICAgIHRoaXMuV0lEVEggPSB0aGlzLmNhbnZhcy53aWR0aDsKICAgICAgdGhpcy5jdHggPSB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KCcyZCcpOwogICAgICB0aGlzLmdob3N0Y2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZ2NhbnZhcycpOwogICAgICB0aGlzLmdob3N0Y2FudmFzLmhlaWdodCA9IHRoaXMuSEVJR0hUOwogICAgICB0aGlzLmdob3N0Y2FudmFzLndpZHRoID0gdGhpcy5XSURUSDsKICAgICAgdGhpcy5nY3R4ID0gdGhpcy5naG9zdGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpOwogICAgICAKICAgICAgLy9maXhlcyBhIHByb2JsZW0gd2hlcmUgZG91YmxlIGNsaWNraW5nIGNhdXNlcyB0ZXh0IHRvIGdldCBzZWxlY3RlZCBvbiB0aGUgY2FudmFzCiAgICAgIHRoaXMuY2FudmFzLm9uc2VsZWN0c3RhcnQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBmYWxzZTsgfQogICAgICAKICAgICAgLy8gZml4ZXMgbW91c2UgY28tb3JkaW5hdGUgcHJvYmxlbXMgd2hlbiB0aGVyZSdzIGEgYm9yZGVyIG9yIHBhZGRpbmcKICAgICAgLy8gc2VlIGdldE1vdXNlIGZvciBtb3JlIGRldGFpbAogICAgICBpZiAoZG9jdW1lbnQuZGVmYXVsdFZpZXcgJiYgZG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZSkgewogICAgICAgIHRoaXMuc3R5bGVQYWRkaW5nTGVmdCA9IHBhcnNlSW50KGRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUodGhpcy5jYW52YXMsIG51bGwpWydwYWRkaW5nTGVmdCddLCAxMCkgICAgIHx8IDA7CiAgICAgICAgdGhpcy5zdHlsZVBhZGRpbmdUb3AgID0gcGFyc2VJbnQoZG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLmNhbnZhcywgbnVsbClbJ3BhZGRpbmdUb3AnXSwgMTApICAgICAgfHwgMDsKICAgICAgICB0aGlzLnN0eWxlQm9yZGVyTGVmdCAgPSBwYXJzZUludChkb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKHRoaXMuY2FudmFzLCBudWxsKVsnYm9yZGVyTGVmdFdpZHRoJ10sIDEwKSB8fCAwOwogICAgICAgIHRoaXMuc3R5bGVCb3JkZXJUb3AgICA9IHBhcnNlSW50KGRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUodGhpcy5jYW52YXMsIG51bGwpWydib3JkZXJUb3BXaWR0aCddLCAxMCkgIHx8IDA7CiAgICAgIH0KICAgICAgCiAgICAgIC8vIG1ha2UgbWFpbkRyYXcoKSBmaXJlIGV2ZXJ5IElOVEVSVkFMIG1pbGxpc2Vjb25kcwogICAgICBzZXRJbnRlcnZhbCh0aGlzLm1haW5EcmF3LCB0aGlzLklOVEVSVkFMKTsKICAgICAgCiAgICAgIC8vIHNldCBvdXIgZXZlbnRzLiBVcCBhbmQgZG93biBhcmUgZm9yIGRyYWdnaW5nLAogICAgICAvLyBkb3VibGUgY2xpY2sgaXMgZm9yIG1ha2luZyBuZXcgYm94ZXMKICAgICAgdGhpcy5jYW52YXMub25tb3VzZWRvd24gPSB0aGlzLm1vdXNlRG93bjsKICAgICAgdGhpcy5jYW52YXMub25tb3VzZXVwID0gdGhpcy5tb3VzZVVwOwogICAgICB0aGlzLmNhbnZhcy5vbmRibGNsaWNrID0gdGhpcy5hZGRTaGFwZTsKICAgICAgdGhpcy5jYW52YXMub25tb3VzZW1vdmUgPSB0aGlzLm1vdXNlTW92ZTsKICAgICAgCiAgICAgIC8vIHNldCB1cCB0aGUgc2VsZWN0aW9uIGhhbmRsZSBib3hlcwogICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDg7IGkgKyspIHsKICAgICAgICB2YXIgcmVjdCA9IG5ldyBSZWN0YW5nbGU7CiAgICAgICAgdGhpcy5zZWxlY3Rpb25IYW5kbGVzLnB1c2gocmVjdCk7CiAgICAgIH0KICAgICAgCiAgICAgIC8vIGFkZCBjdXN0b20gaW5pdGlhbGl6YXRpb24gaGVyZToKCiAgICAgIAogICAgICAvLyBhZGQgYSBsYXJnZSBncmVlbiByZWN0YW5nbGUKICAgICAgdGhpcy5hZGRSZWN0KDI2MCwgNzAsIDYwLCA2NSwgJ3JnYmEoMCwyMDUsMCwwLjcpJyk7CiAgICAgIAogICAgICAvLyBhZGQgYSBncmVlbi1ibHVlIHJlY3RhbmdsZQogICAgICB0aGlzLmFkZFJlY3QoMjQwLCAxMjAsIDQwLCA0MCwgJ3JnYmEoMiwxNjUsMTY1LDAuNyknKTsgIAogICAgICAKICAgICAgLy8gYWRkIGEgc21hbGxlciBwdXJwbGUgcmVjdGFuZ2xlCiAgICAgIHRoaXMuYWRkUmVjdCg0NSwgNjAsIDI1LCAyNSwgJ3JnYmEoMTUwLDE1MCwyNTAsMC43KScpOwoKICAgIH0sCiAgICBtZXRob2RzOiB7CiAgICAgICAgYWRkUmVjdCh4LCB5LCB3LCBoLCBmaWxsKSB7CiAgICAgICAgICB2YXIgcmVjdCA9IG5ldyBSZWN0YW5nbGU7CiAgICAgICAgICByZWN0LnggPSB4OwogICAgICAgICAgcmVjdC55ID0geTsKICAgICAgICAgIHJlY3QudyA9IHcKICAgICAgICAgIHJlY3QuaCA9IGg7CiAgICAgICAgICByZWN0LmZpbGwgPSBmaWxsOwogICAgICAgICAgdGhpcy5zaGFwZXMucHVzaChyZWN0KTsKICAgICAgICAgIHRoaXMuaW52YWxpZGF0ZSgpOwogICAgICB9LAogICAgICAvL3dpcGVzIHRoZSBjYW52YXMgY29udGV4dAogICAgICBjbGVhcihjKSB7CiAgICAgICAgYy5jbGVhclJlY3QoMCwgMCwgdGhpcy5XSURUSCwgdGhpcy5IRUlHSFQpOwogICAgICB9LAogICAgICAvLyBNYWluIGRyYXcgbG9vcC4KICAgICAgLy8gV2hpbGUgZHJhdyBpcyBjYWxsZWQgYXMgb2Z0ZW4gYXMgdGhlIElOVEVSVkFMIHZhcmlhYmxlIGRlbWFuZHMsCiAgICAgIC8vIEl0IG9ubHkgZXZlciBkb2VzIHNvbWV0aGluZyBpZiB0aGUgY2FudmFzIGdldHMgaW52YWxpZGF0ZWQgYnkgb3VyIGNvZGUKICAgICAgbWFpbkRyYXcoKSB7CiAgICAgICAgaWYgKHRoaXMuY2FudmFzVmFsaWQgPT0gZmFsc2UpIHsKICAgICAgICAgIHRoaXMuY2xlYXIodGhpcy5jdHgpOwogICAgICAgICAgCiAgICAgICAgICAvLyBBZGQgc3R1ZmYgeW91IHdhbnQgZHJhd24gaW4gdGhlIGJhY2tncm91bmQgYWxsIHRoZSB0aW1lIGhlcmUKICAgICAgICAgIAogICAgICAgICAgLy8gZHJhdyBhbGwgYm94ZXMKICAgICAgICAgIHZhciBsID0gdGhpcy5zaGFwZXMubGVuZ3RoOwogICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHsKICAgICAgICAgICAgdGhpcy5zaGFwZXNbaV0uZHJhdyh0aGlzLmN0eCwgdGhpcyk7CiAgICAgICAgICB9CiAgICAgICAgICAKICAgICAgICAgIC8vIEFkZCBzdHVmZiB5b3Ugd2FudCBkcmF3biBvbiB0b3AgYWxsIHRoZSB0aW1lIGhlcmUKICAgICAgICAgIAogICAgICAgICAgdGhpcy5jYW52YXNWYWxpZCA9IHRydWU7CiAgICAgICAgfQogICAgICB9LAogICAgICAvLyBIYXBwZW5zIHdoZW4gdGhlIG1vdXNlIGlzIG1vdmluZyBpbnNpZGUgdGhlIGNhbnZhcwogICAgICBtb3VzZU1vdmUoZSl7CiAgICAgICAgaWYgKHRoaXMuaXNEcmFnKSB7CiAgICAgICAgICB0aGlzLmdldE1vdXNlKGUpOwogICAgICAgICAgCiAgICAgICAgICB0aGlzLnNlbGVjdGVkU2hhcGUueCA9IHRoaXMubW91c2VfeCAtIHRoaXMub2Zmc2V0X3g7CiAgICAgICAgICB0aGlzLnNlbGVjdGVkU2hhcGUueSA9IHRoaXMubW91c2VfeSAtIHRoaXMub2Zmc2V0X3k7ICAgCiAgICAgICAgICAKICAgICAgICAgIC8vIHNvbWV0aGluZyBpcyBjaGFuZ2luZyBwb3NpdGlvbiBzbyB3ZSBiZXR0ZXIgaW52YWxpZGF0ZSB0aGUgY2FudmFzIQogICAgICAgICAgdGhpcy5pbnZhbGlkYXRlKCk7CiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmlzUmVzaXplRHJhZykgewogICAgICAgICAgLy8gdGltZSBybyByZXNpemUhCiAgICAgICAgICB2YXIgb2xkeCA9IHRoaXMuc2VsZWN0ZWRTaGFwZS54OwogICAgICAgICAgdmFyIG9sZHkgPSB0aGlzLnNlbGVjdGVkU2hhcGUueTsKICAgICAgICAgIAogICAgICAgICAgLy8gMCAgMSAgMgogICAgICAgICAgLy8gMyAgICAgNAogICAgICAgICAgLy8gNSAgNiAgNwogICAgICAgICAgc3dpdGNoICh0aGlzLmV4cGVjdFJlc2l6ZSkgewogICAgICAgICAgICBjYXNlIDA6CiAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZFNoYXBlLnggPSB0aGlzLm1vdXNlX3g7CiAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZFNoYXBlLnkgPSB0aGlzLm1vdXNlX3k7CiAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZFNoYXBlLncgKz0gb2xkeCAtIHRoaXMubW91c2VfeDsKICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkU2hhcGUuaCArPSBvbGR5IC0gdGhpcy5tb3VzZV95OwogICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICBjYXNlIDE6CiAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZFNoYXBlLnkgPSB0aGlzLm1vdXNlX3k7CiAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZFNoYXBlLmggKz0gb2xkeSAtIHRoaXMubW91c2VfeTsKICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgY2FzZSAyOgogICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRTaGFwZS55ID0gdGhpcy5tb3VzZV95OwogICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRTaGFwZS53ID0gdGhpcy5tb3VzZV94IC0gb2xkeDsKICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkU2hhcGUuaCArPSBvbGR5IC0gdGhpcy5tb3VzZV95OwogICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICBjYXNlIDM6CiAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZFNoYXBlLnggPSB0aGlzLm1vdXNlX3g7CiAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZFNoYXBlLncgKz0gb2xkeCAtIHRoaXMubW91c2VfeDsKICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgY2FzZSA0OgogICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRTaGFwZS53ID0gdGhpcy5tb3VzZV94IC0gb2xkeDsKICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgY2FzZSA1OgogICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRTaGFwZS54ID0gdGhpcy5tb3VzZV94OwogICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRTaGFwZS53ICs9IG9sZHggLSB0aGlzLm1vdXNlX3g7CiAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZFNoYXBlLmggPSB0aGlzLm1vdXNlX3kgLSBvbGR5OwogICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICBjYXNlIDY6CiAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZFNoYXBlLmggPSB0aGlzLm1vdXNlX3kgLSBvbGR5OwogICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICBjYXNlIDc6CiAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZFNoYXBlLncgPSB0aGlzLm1vdXNlX3ggLSBvbGR4OwogICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRTaGFwZS5oID0gdGhpcy5tb3VzZV95IC0gb2xkeTsKICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgIH0KICAgICAgICAgIAogICAgICAgICAgdGhpcy5pbnZhbGlkYXRlKCk7CiAgICAgICAgfQogICAgICAgIAogICAgICAgIHRoaXMuZ2V0TW91c2UoZSk7CiAgICAgICAgLy8gaWYgdGhlcmUncyBhIHNlbGVjdGlvbiBzZWUgaWYgd2UgZ3JhYmJlZCBvbmUgb2YgdGhlIHNlbGVjdGlvbiBoYW5kbGVzCiAgICAgICAgaWYgKHRoaXMuc2VsZWN0ZWRTaGFwZSAhPT0gbnVsbCAmJiAhdGhpcy5pc1Jlc2l6ZURyYWcpIHsKICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgODsgaSsrKSB7CiAgICAgICAgICAgIC8vIDAgIDEgIDIKICAgICAgICAgICAgLy8gMyAgICAgNAogICAgICAgICAgICAvLyA1ICA2ICA3CiAgICAgICAgICAgIAogICAgICAgICAgICB2YXIgY3VyID0gdGhpcy5zZWxlY3Rpb25IYW5kbGVzW2ldOwogICAgICAgICAgICAKICAgICAgICAgICAgLy8gd2UgZG9udCBuZWVkIHRvIHVzZSB0aGUgZ2hvc3QgY29udGV4dCBiZWNhdXNlCiAgICAgICAgICAgIC8vIHNlbGVjdGlvbiBoYW5kbGVzIHdpbGwgYWx3YXlzIGJlIHJlY3RhbmdsZXMKICAgICAgICAgICAgaWYgKHRoaXMubW91c2VfeCA+PSBjdXIueCAmJiB0aGlzLm1vdXNlX3ggPD0gY3VyLnggKyB0aGlzLnNlbGVjdGlvbkJveFNpemUgJiYKICAgICAgICAgICAgICAgIHRoaXMubW91c2VfeSA+PSBjdXIueSAmJiB0aGlzLm1vdXNlX3kgPD0gY3VyLnkgKyB0aGlzLnNlbGVjdGlvbkJveFNpemUpIHsKICAgICAgICAgICAgICAvLyB3ZSBmb3VuZCBvbmUhCiAgICAgICAgICAgICAgdGhpcy5leHBlY3RSZXNpemUgPSBpOwogICAgICAgICAgICAgIHRoaXMuaW52YWxpZGF0ZSgpOwogICAgICAgICAgICAgIAogICAgICAgICAgICAgIHN3aXRjaCAoaSkgewogICAgICAgICAgICAgICAgY2FzZSAwOgogICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkQ3Vyc29yPSdudy1yZXNpemUnOwogICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgIGNhc2UgMToKICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZEN1cnNvcj0nbi1yZXNpemUnOwogICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgIGNhc2UgMjoKICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZEN1cnNvcj0nbmUtcmVzaXplJzsKICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICBjYXNlIDM6CiAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRDdXJzb3I9J3ctcmVzaXplJzsKICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICBjYXNlIDQ6CiAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRDdXJzb3I9J2UtcmVzaXplJzsKICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICBjYXNlIDU6CiAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRDdXJzb3I9J3N3LXJlc2l6ZSc7CiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgY2FzZSA2OgogICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkQ3Vyc29yPSdzLXJlc2l6ZSc7CiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgY2FzZSA3OgogICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkQ3Vyc29yPSdzZS1yZXNpemUnOwogICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgcmV0dXJuOwogICAgICAgICAgICB9CiAgICAgICAgICAgIAogICAgICAgICAgfQogICAgICAgICAgLy8gbm90IG92ZXIgYSBzZWxlY3Rpb24gYm94LCByZXR1cm4gdG8gbm9ybWFsCiAgICAgICAgICB0aGlzLmlzUmVzaXplRHJhZyA9IGZhbHNlOwogICAgICAgICAgdGhpcy5leHBlY3RSZXNpemUgPSAtMTsKICAgICAgICAgIHRoaXMuc2VsZWN0ZWRDdXJzb3I9J2F1dG8nOwogICAgICAgIH0KICAgICAgICAKICAgICAgfSwKICAgICAgLy8gSGFwcGVucyB3aGVuIHRoZSBtb3VzZSBpcyBjbGlja2VkIGluIHRoZSBjYW52YXMKICAgICAgbW91c2VEb3duKGUpewogICAgICAgIHRoaXMuZ2V0TW91c2UoZSk7CiAgICAgICAgCiAgICAgICAgLy93ZSBhcmUgb3ZlciBhIHNlbGVjdGlvbiBib3gKICAgICAgICBpZiAodGhpcy5leHBlY3RSZXNpemUgIT09IC0xKSB7CiAgICAgICAgICB0aGlzLmlzUmVzaXplRHJhZyA9IHRydWU7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIAogICAgICAgIHRoaXMuY2xlYXIodGhpcy5nY3R4KTsKICAgICAgICB2YXIgbCA9IHRoaXMuc2hhcGVzLmxlbmd0aDsKICAgICAgICBmb3IgKHZhciBpID0gbC0xOyBpID49IDA7IGktLSkgewogICAgICAgICAgLy8gZHJhdyBzaGFwZSBvbnRvIGdob3N0IGNvbnRleHQKICAgICAgICAgIHRoaXMuc2hhcGVzW2ldLmRyYXcodGhpcy5nY3R4LCAnYmxhY2snKTsKICAgICAgICAgIAogICAgICAgICAgLy8gZ2V0IGltYWdlIGRhdGEgYXQgdGhlIG1vdXNlIHgseSBwaXhlbAogICAgICAgICAgdmFyIGltYWdlRGF0YSA9IHRoaXMuZ2N0eC5nZXRJbWFnZURhdGEodGhpcy5tb3VzZV94LCB0aGlzLm1vdXNlX3ksIDEsIDEpOwogICAgICAgICAgCiAgICAgICAgICAvLyBpZiB0aGUgbW91c2UgcGl4ZWwgZXhpc3RzLCBzZWxlY3QgYW5kIGJyZWFrCiAgICAgICAgICBpZiAoaW1hZ2VEYXRhLmRhdGFbM10gPiAwKSB7CiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRTaGFwZSA9IHRoaXMuc2hhcGVzW2ldOwogICAgICAgICAgICB0aGlzLm9mZnNldF94ID0gdGhpcy5tb3VzZV94IC0gdGhpcy5zZWxlY3RlZFNoYXBlLng7CiAgICAgICAgICAgIHRoaXMub2Zmc2V0X3kgPSB0aGlzLm1vdXNlX3kgLSB0aGlzLnNlbGVjdGVkU2hhcGUueTsKICAgICAgICAgICAgdGhpcy5zZWxlY3RlZFNoYXBlLnggPSB0aGlzLm1vdXNlX3ggLSB0aGlzLm9mZnNldF94OwogICAgICAgICAgICB0aGlzLnNlbGVjdGVkU2hhcGUueSA9IHRoaXMubW91c2VfeSAtIHRoaXMub2Zmc2V0X3k7CiAgICAgICAgICAgIHRoaXMuaXNEcmFnID0gdHJ1ZTsKICAgICAgICAgICAgCiAgICAgICAgICAgIHRoaXMuaW52YWxpZGF0ZSgpOwogICAgICAgICAgICB0aGlzLmNsZWFyKHRoaXMuZ2N0eCk7CiAgICAgICAgICAgIHJldHVybjsKICAgICAgICAgIH0KICAgICAgICAgIAogICAgICAgIH0KICAgICAgICAvLyBoYXZlbnQgcmV0dXJuZWQgbWVhbnMgd2UgaGF2ZSBzZWxlY3RlZCBub3RoaW5nCiAgICAgICAgdGhpcy5zZWxlY3RlZFNoYXBlID0gbnVsbDsKICAgICAgICAvLyBjbGVhciB0aGUgZ2hvc3QgY2FudmFzIGZvciBuZXh0IHRpbWUKICAgICAgICB0aGlzLmNsZWFyKHRoaXMuZ2N0eCk7CiAgICAgICAgLy8gaW52YWxpZGF0ZSBiZWNhdXNlIHdlIG1pZ2h0IG5lZWQgdGhlIHNlbGVjdGlvbiBib3JkZXIgdG8gZGlzYXBwZWFyCiAgICAgICAgdGhpcy5pbnZhbGlkYXRlKCk7CiAgICAgIH0sCiAgICAgIG1vdXNlVXAoKXsKICAgICAgICB0aGlzLmlzRHJhZyA9IGZhbHNlOwogICAgICAgIHRoaXMuaXNSZXNpemVEcmFnID0gZmFsc2U7CiAgICAgICAgdGhpcy5leHBlY3RSZXNpemUgPSAtMTsKICAgICAgfSwKICAgICAgYWRkU2hhcGUoZSkgewogICAgICAgIHRoaXMuZ2V0TW91c2UoZSk7CiAgICAgICAgLy8gRGVmYXVsdCBzaXplCiAgICAgICAgdmFyIHdpZHRoID0gMjA7CiAgICAgICAgdmFyIGhlaWdodCA9IDIwOwogICAgICAgIHRoaXMuYWRkUmVjdCh0aGlzLm1vdXNlX3ggLSAod2lkdGggLyAyKSwgdGhpcy5tb3VzZV95IC0gKGhlaWdodCAvIDIpLCB3aWR0aCwgaGVpZ2h0LCAncmdiYSgyMjAsMjA1LDY1LDAuNyknKTsKICAgICAgfSwKICAgICAgaW52YWxpZGF0ZSgpIHsKICAgICAgICB0aGlzLmNhbnZhc1ZhbGlkID0gZmFsc2U7CiAgICAgIH0sCiAgICAgIC8vIFNldHMgbW91c2VfeCxtb3VzZV95IHRvIHRoZSBtb3VzZSBwb3NpdGlvbiByZWxhdGl2ZSB0byB0aGUgY2FudmFzCiAgICAgIC8vIHVuZm9ydHVuYXRlbHkgdGhpcyBjYW4gYmUgdHJpY2t5LCB3ZSBoYXZlIHRvIHdvcnJ5IGFib3V0IHBhZGRpbmcgYW5kIGJvcmRlcnMKICAgICAgZ2V0TW91c2UoZSkgewogICAgICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMuY2FudmFzLCBvZmZzZXRYID0gMCwgb2Zmc2V0WSA9IDA7CgogICAgICAgICAgICBpZiAoZWxlbWVudC5vZmZzZXRQYXJlbnQpIHsKICAgICAgICAgICAgICBkbyB7CiAgICAgICAgICAgICAgICBvZmZzZXRYICs9IGVsZW1lbnQub2Zmc2V0TGVmdDsKICAgICAgICAgICAgICAgIG9mZnNldFkgKz0gZWxlbWVudC5vZmZzZXRUb3A7CiAgICAgICAgICAgICAgfSB3aGlsZSAoKGVsZW1lbnQgPSBlbGVtZW50Lm9mZnNldFBhcmVudCkpOwogICAgICAgICAgICB9CgogICAgICAgICAgICAvLyBBZGQgcGFkZGluZyBhbmQgYm9yZGVyIHN0eWxlIHdpZHRocyB0byBvZmZzZXQKICAgICAgICAgICAgb2Zmc2V0WCArPSB0aGlzLnN0eWxlUGFkZGluZ0xlZnQ7CiAgICAgICAgICAgIG9mZnNldFkgKz0gdGhpcy5zdHlsZVBhZGRpbmdUb3A7CgogICAgICAgICAgICBvZmZzZXRYICs9IHRoaXMuc3R5bGVCb3JkZXJMZWZ0OwogICAgICAgICAgICBvZmZzZXRZICs9IHRoaXMuc3R5bGVCb3JkZXJUb3A7CgogICAgICAgICAgICB0aGlzLm1vdXNlX3ggPSBlLnBhZ2VYIC0gb2Zmc2V0WDsKICAgICAgICAgICAgdGhpcy5tb3VzZV95ID0gZS5wYWdlWSAtIG9mZnNldFkKICAgICAgfQogICAgfQp9Cg=="},{"version":3,"sources":["App.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAiCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA","file":"App.vue","sourceRoot":"src","sourcesContent":["<template>\n  <div id=\"app\">\n    <div id=\"container\">\n    <canvas id=\"canvas\" width=\"400\" height=\"300\"  v-bind:style=\"{cursor: selectedCursor}\">\n    This text is displayed if your browser does not support HTML5 Canvas.\n    </canvas>\n    </div>\n  </div>\n</template>\n\n<style>\n#app {\n  font-family: Avenir, Helvetica, Arial, sans-serif;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n  text-align: center;\n  color: #2c3e50;\n}\n\n#nav {\n  padding: 30px;\n}\n\n#nav a {\n  font-weight: bold;\n  color: #2c3e50;\n}\n\n#nav a.router-link-exact-active {\n  color: #42b983;\n}\n</style>\n<script>\nimport Rectangle from './models/Rectangle';\nexport default { \n  data() {\n        return {\n            shapes : [],\n            // Array to carry the selection handles (drag boxes) for each shape selection\n            selectionHandles: [],\n            // Hold canvas information\n            canvas: null,\n            ctx: null,\n            WIDTH: 0,\n            HEIGHT: 0,\n            // Interval at which the canvas is updated and redrawn again in milliseconds\n            INTERVAL: 20,\n            // Flags for current selection mode (drag the shape or resizing it)\n            isDrag: false,\n            isResizeDrag: false,\n            // The number of selection handle which the mouse is over it\n            expectResize: -1,\n            // Mouse Coordinates\n            mouse_x: 0, \n            mouse_y: 0,\n            // Redraw flag\n            // when set to true, the canvas will redraw everything\n            // invalidate() just sets this to false right now\n            // we want to call invalidate() whenever we make a change\n            canvasValid: false,\n            selectedShape: null,\n            // The following are the attributes of the selection border and corners\n            selectionColor: '#CC0000',\n            selectionWidth: 2,\n            selectionBoxColor: 'darkred', // New for selection boxes\n            selectionBoxSize: 6,\n            // Fake Canvas and CanvasContext \n            ghostcanvas: null,\n            gctx: null,\n            // since we can drag from anywhere in a node\n            // instead of just its x/y corner, we need to save\n            // the offset of the mouse when we start dragging.\n            offset_x: 0, \n            offset_y:0,\n            // Padding and border style widths for mouse offsets to maintain our calculations on click\n            stylePaddingLeft: 0, \n            stylePaddingTop: 0, \n            styleBorderLeft: 0, \n            styleBorderTop: 0,\n            selectedCursor: 'auto'\n        }\n    },\n    mounted() {\n      // Canvas initialization\n      this.canvas = document.getElementById('canvas');\n      this.HEIGHT = this.canvas.height;\n      this.WIDTH = this.canvas.width;\n      this.ctx = this.canvas.getContext('2d');\n      this.ghostcanvas = document.createElement('gcanvas');\n      this.ghostcanvas.height = this.HEIGHT;\n      this.ghostcanvas.width = this.WIDTH;\n      this.gctx = this.ghostcanvas.getContext('2d');\n      \n      //fixes a problem where double clicking causes text to get selected on the canvas\n      this.canvas.onselectstart = function () { return false; }\n      \n      // fixes mouse co-ordinate problems when there's a border or padding\n      // see getMouse for more detail\n      if (document.defaultView && document.defaultView.getComputedStyle) {\n        this.stylePaddingLeft = parseInt(document.defaultView.getComputedStyle(this.canvas, null)['paddingLeft'], 10)     || 0;\n        this.stylePaddingTop  = parseInt(document.defaultView.getComputedStyle(this.canvas, null)['paddingTop'], 10)      || 0;\n        this.styleBorderLeft  = parseInt(document.defaultView.getComputedStyle(this.canvas, null)['borderLeftWidth'], 10) || 0;\n        this.styleBorderTop   = parseInt(document.defaultView.getComputedStyle(this.canvas, null)['borderTopWidth'], 10)  || 0;\n      }\n      \n      // make mainDraw() fire every INTERVAL milliseconds\n      setInterval(this.mainDraw, this.INTERVAL);\n      \n      // set our events. Up and down are for dragging,\n      // double click is for making new boxes\n      this.canvas.onmousedown = this.mouseDown;\n      this.canvas.onmouseup = this.mouseUp;\n      this.canvas.ondblclick = this.addShape;\n      this.canvas.onmousemove = this.mouseMove;\n      \n      // set up the selection handle boxes\n      for (var i = 0; i < 8; i ++) {\n        var rect = new Rectangle;\n        this.selectionHandles.push(rect);\n      }\n      \n      // add custom initialization here:\n\n      \n      // add a large green rectangle\n      this.addRect(260, 70, 60, 65, 'rgba(0,205,0,0.7)');\n      \n      // add a green-blue rectangle\n      this.addRect(240, 120, 40, 40, 'rgba(2,165,165,0.7)');  \n      \n      // add a smaller purple rectangle\n      this.addRect(45, 60, 25, 25, 'rgba(150,150,250,0.7)');\n\n    },\n    methods: {\n        addRect(x, y, w, h, fill) {\n          var rect = new Rectangle;\n          rect.x = x;\n          rect.y = y;\n          rect.w = w\n          rect.h = h;\n          rect.fill = fill;\n          this.shapes.push(rect);\n          this.invalidate();\n      },\n      //wipes the canvas context\n      clear(c) {\n        c.clearRect(0, 0, this.WIDTH, this.HEIGHT);\n      },\n      // Main draw loop.\n      // While draw is called as often as the INTERVAL variable demands,\n      // It only ever does something if the canvas gets invalidated by our code\n      mainDraw() {\n        if (this.canvasValid == false) {\n          this.clear(this.ctx);\n          \n          // Add stuff you want drawn in the background all the time here\n          \n          // draw all boxes\n          var l = this.shapes.length;\n          for (var i = 0; i < l; i++) {\n            this.shapes[i].draw(this.ctx, this);\n          }\n          \n          // Add stuff you want drawn on top all the time here\n          \n          this.canvasValid = true;\n        }\n      },\n      // Happens when the mouse is moving inside the canvas\n      mouseMove(e){\n        if (this.isDrag) {\n          this.getMouse(e);\n          \n          this.selectedShape.x = this.mouse_x - this.offset_x;\n          this.selectedShape.y = this.mouse_y - this.offset_y;   \n          \n          // something is changing position so we better invalidate the canvas!\n          this.invalidate();\n        } else if (this.isResizeDrag) {\n          // time ro resize!\n          var oldx = this.selectedShape.x;\n          var oldy = this.selectedShape.y;\n          \n          // 0  1  2\n          // 3     4\n          // 5  6  7\n          switch (this.expectResize) {\n            case 0:\n              this.selectedShape.x = this.mouse_x;\n              this.selectedShape.y = this.mouse_y;\n              this.selectedShape.w += oldx - this.mouse_x;\n              this.selectedShape.h += oldy - this.mouse_y;\n              break;\n            case 1:\n              this.selectedShape.y = this.mouse_y;\n              this.selectedShape.h += oldy - this.mouse_y;\n              break;\n            case 2:\n              this.selectedShape.y = this.mouse_y;\n              this.selectedShape.w = this.mouse_x - oldx;\n              this.selectedShape.h += oldy - this.mouse_y;\n              break;\n            case 3:\n              this.selectedShape.x = this.mouse_x;\n              this.selectedShape.w += oldx - this.mouse_x;\n              break;\n            case 4:\n              this.selectedShape.w = this.mouse_x - oldx;\n              break;\n            case 5:\n              this.selectedShape.x = this.mouse_x;\n              this.selectedShape.w += oldx - this.mouse_x;\n              this.selectedShape.h = this.mouse_y - oldy;\n              break;\n            case 6:\n              this.selectedShape.h = this.mouse_y - oldy;\n              break;\n            case 7:\n              this.selectedShape.w = this.mouse_x - oldx;\n              this.selectedShape.h = this.mouse_y - oldy;\n              break;\n          }\n          \n          this.invalidate();\n        }\n        \n        this.getMouse(e);\n        // if there's a selection see if we grabbed one of the selection handles\n        if (this.selectedShape !== null && !this.isResizeDrag) {\n          for (var i = 0; i < 8; i++) {\n            // 0  1  2\n            // 3     4\n            // 5  6  7\n            \n            var cur = this.selectionHandles[i];\n            \n            // we dont need to use the ghost context because\n            // selection handles will always be rectangles\n            if (this.mouse_x >= cur.x && this.mouse_x <= cur.x + this.selectionBoxSize &&\n                this.mouse_y >= cur.y && this.mouse_y <= cur.y + this.selectionBoxSize) {\n              // we found one!\n              this.expectResize = i;\n              this.invalidate();\n              \n              switch (i) {\n                case 0:\n                  this.selectedCursor='nw-resize';\n                  break;\n                case 1:\n                  this.selectedCursor='n-resize';\n                  break;\n                case 2:\n                  this.selectedCursor='ne-resize';\n                  break;\n                case 3:\n                  this.selectedCursor='w-resize';\n                  break;\n                case 4:\n                  this.selectedCursor='e-resize';\n                  break;\n                case 5:\n                  this.selectedCursor='sw-resize';\n                  break;\n                case 6:\n                  this.selectedCursor='s-resize';\n                  break;\n                case 7:\n                  this.selectedCursor='se-resize';\n                  break;\n              }\n              return;\n            }\n            \n          }\n          // not over a selection box, return to normal\n          this.isResizeDrag = false;\n          this.expectResize = -1;\n          this.selectedCursor='auto';\n        }\n        \n      },\n      // Happens when the mouse is clicked in the canvas\n      mouseDown(e){\n        this.getMouse(e);\n        \n        //we are over a selection box\n        if (this.expectResize !== -1) {\n          this.isResizeDrag = true;\n          return;\n        }\n        \n        this.clear(this.gctx);\n        var l = this.shapes.length;\n        for (var i = l-1; i >= 0; i--) {\n          // draw shape onto ghost context\n          this.shapes[i].draw(this.gctx, 'black');\n          \n          // get image data at the mouse x,y pixel\n          var imageData = this.gctx.getImageData(this.mouse_x, this.mouse_y, 1, 1);\n          \n          // if the mouse pixel exists, select and break\n          if (imageData.data[3] > 0) {\n            this.selectedShape = this.shapes[i];\n            this.offset_x = this.mouse_x - this.selectedShape.x;\n            this.offset_y = this.mouse_y - this.selectedShape.y;\n            this.selectedShape.x = this.mouse_x - this.offset_x;\n            this.selectedShape.y = this.mouse_y - this.offset_y;\n            this.isDrag = true;\n            \n            this.invalidate();\n            this.clear(this.gctx);\n            return;\n          }\n          \n        }\n        // havent returned means we have selected nothing\n        this.selectedShape = null;\n        // clear the ghost canvas for next time\n        this.clear(this.gctx);\n        // invalidate because we might need the selection border to disappear\n        this.invalidate();\n      },\n      mouseUp(){\n        this.isDrag = false;\n        this.isResizeDrag = false;\n        this.expectResize = -1;\n      },\n      addShape(e) {\n        this.getMouse(e);\n        // Default size\n        var width = 20;\n        var height = 20;\n        this.addRect(this.mouse_x - (width / 2), this.mouse_y - (height / 2), width, height, 'rgba(220,205,65,0.7)');\n      },\n      invalidate() {\n        this.canvasValid = false;\n      },\n      // Sets mouse_x,mouse_y to the mouse position relative to the canvas\n      // unfortunately this can be tricky, we have to worry about padding and borders\n      getMouse(e) {\n            var element = this.canvas, offsetX = 0, offsetY = 0;\n\n            if (element.offsetParent) {\n              do {\n                offsetX += element.offsetLeft;\n                offsetY += element.offsetTop;\n              } while ((element = element.offsetParent));\n            }\n\n            // Add padding and border style widths to offset\n            offsetX += this.stylePaddingLeft;\n            offsetY += this.stylePaddingTop;\n\n            offsetX += this.styleBorderLeft;\n            offsetY += this.styleBorderTop;\n\n            this.mouse_x = e.pageX - offsetX;\n            this.mouse_y = e.pageY - offsetY\n      }\n    }\n}\n</script>"]}]}